// **********************************************************************
//
// Copyright (c) 2003-2017 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************
//
// Ice version 3.7.0
//
// <auto-generated>
//
// Generated from file `messager.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __messager_h__
#define __messager_h__

#include <IceUtil/PushDisableWarnings.h>
#include <Ice/ProxyF.h>
#include <Ice/ObjectF.h>
#include <Ice/ValueF.h>
#include <Ice/Exception.h>
#include <Ice/LocalObject.h>
#include <Ice/StreamHelpers.h>
#include <Ice/Comparable.h>
#include <Ice/Proxy.h>
#include <Ice/Object.h>
#include <Ice/GCObject.h>
#include <Ice/Value.h>
#include <Ice/Incoming.h>
#include <Ice/FactoryTableInit.h>
#include <IceUtil/ScopedArray.h>
#include <Ice/Optional.h>
#include <Ice/Identity.h>
#include <IceUtil/UndefSysMacros.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 307
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 > 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 0
#       error Ice patch level mismatch!
#   endif
#endif

#ifdef ICE_CPP11_MAPPING // C++11 mapping

namespace Messager
{

class Receiver;
class ReceiverPrx;
class Box;
class BoxPrx;
class Deliver;
class DeliverPrx;

}

namespace Messager
{

struct BoxInfo
{
    ::std::string address;

    std::tuple<const ::std::string&> ice_tuple() const
    {
        return std::tie(address);
    }
};

using BoxList = ::std::vector<::Messager::BoxInfo>;

struct Owner
{
    ::std::string id;
    ::Messager::BoxList boxs;

    std::tuple<const ::std::string&, const ::Messager::BoxList&> ice_tuple() const
    {
        return std::tie(id, boxs);
    }
};

using OwnerList = ::std::vector<::Messager::Owner>;

struct Message
{
    ::Messager::OwnerList to;
    ::Messager::Owner from;
    ::std::string subject;

    std::tuple<const ::Messager::OwnerList&, const ::Messager::Owner&, const ::std::string&> ice_tuple() const
    {
        return std::tie(to, from, subject);
    }
};

using Ice::operator<;
using Ice::operator<=;
using Ice::operator>;
using Ice::operator>=;
using Ice::operator==;
using Ice::operator!=;

}

namespace Messager
{

class Receiver : public virtual ::Ice::Object
{
public:

    using ProxyType = ReceiverPrx;

    virtual bool ice_isA(::std::string, const ::Ice::Current&) const override;
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current&) const override;
    virtual ::std::string ice_id(const ::Ice::Current&) const override;

    static const ::std::string& ice_staticId();

    virtual void onRecv(::Messager::Message, const ::Ice::Current&) = 0;
    bool _iceD_onRecv(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
};

class Box : public virtual ::Ice::Object
{
public:

    using ProxyType = BoxPrx;

    virtual bool ice_isA(::std::string, const ::Ice::Current&) const override;
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current&) const override;
    virtual ::std::string ice_id(const ::Ice::Current&) const override;

    static const ::std::string& ice_staticId();

    virtual bool post(::Messager::Message, const ::Ice::Current&) = 0;
    bool _iceD_post(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void pull(const ::Ice::Current&) = 0;
    bool _iceD_pull(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setReceiver(::std::shared_ptr<::Messager::ReceiverPrx>, const ::Ice::Current&) = 0;
    bool _iceD_setReceiver(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setReceiverId(::Ice::Identity, const ::Ice::Current&) = 0;
    bool _iceD_setReceiverId(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
};

class Deliver : public virtual ::Ice::Object
{
public:

    using ProxyType = DeliverPrx;

    virtual bool ice_isA(::std::string, const ::Ice::Current&) const override;
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current&) const override;
    virtual ::std::string ice_id(const ::Ice::Current&) const override;

    static const ::std::string& ice_staticId();

    virtual bool registerBox(::Messager::BoxInfo, const ::Ice::Current&) = 0;
    bool _iceD_registerBox(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
};

}

namespace Messager
{

class ReceiverPrx : public virtual ::Ice::Proxy<ReceiverPrx, ::Ice::ObjectPrx>
{
public:

    void onRecv(const ::Messager::Message& iceP_msg, const ::Ice::Context& context = Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &Messager::ReceiverPrx::_iceI_onRecv, iceP_msg, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto onRecvAsync(const ::Messager::Message& iceP_msg, const ::Ice::Context& context = Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &Messager::ReceiverPrx::_iceI_onRecv, iceP_msg, context);
    }

    ::std::function<void()>
    onRecvAsync(const ::Messager::Message& iceP_msg,
                ::std::function<void()> response,
                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                ::std::function<void(bool)> sent = nullptr,
                const ::Ice::Context& context = Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(response, ex, sent, this, &Messager::ReceiverPrx::_iceI_onRecv, iceP_msg, context);
    }

    void _iceI_onRecv(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Messager::Message&, const ::Ice::Context&);

    static const ::std::string& ice_staticId();

protected:

    ReceiverPrx() = default;
    friend ::std::shared_ptr<ReceiverPrx> IceInternal::createProxy<ReceiverPrx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
};

class BoxPrx : public virtual ::Ice::Proxy<BoxPrx, ::Ice::ObjectPrx>
{
public:

    bool post(const ::Messager::Message& iceP_msg, const ::Ice::Context& context = Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<bool>(true, this, &Messager::BoxPrx::_iceI_post, iceP_msg, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto postAsync(const ::Messager::Message& iceP_msg, const ::Ice::Context& context = Ice::noExplicitContext)
        -> decltype(::std::declval<P<bool>>().get_future())
    {
        return _makePromiseOutgoing<bool, P>(false, this, &Messager::BoxPrx::_iceI_post, iceP_msg, context);
    }

    ::std::function<void()>
    postAsync(const ::Messager::Message& iceP_msg,
              ::std::function<void(bool)> response,
              ::std::function<void(::std::exception_ptr)> ex = nullptr,
              ::std::function<void(bool)> sent = nullptr,
              const ::Ice::Context& context = Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<bool>(response, ex, sent, this, &Messager::BoxPrx::_iceI_post, iceP_msg, context);
    }

    void _iceI_post(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>&, const ::Messager::Message&, const ::Ice::Context&);

    void pull(const ::Ice::Context& context = Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &Messager::BoxPrx::_iceI_pull, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto pullAsync(const ::Ice::Context& context = Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &Messager::BoxPrx::_iceI_pull, context);
    }

    ::std::function<void()>
    pullAsync(::std::function<void()> response,
              ::std::function<void(::std::exception_ptr)> ex = nullptr,
              ::std::function<void(bool)> sent = nullptr,
              const ::Ice::Context& context = Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(response, ex, sent, this, &Messager::BoxPrx::_iceI_pull, context);
    }

    void _iceI_pull(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);

    void setReceiver(const ::std::shared_ptr<::Messager::ReceiverPrx>& iceP_val, const ::Ice::Context& context = Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &Messager::BoxPrx::_iceI_setReceiver, iceP_val, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto setReceiverAsync(const ::std::shared_ptr<::Messager::ReceiverPrx>& iceP_val, const ::Ice::Context& context = Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &Messager::BoxPrx::_iceI_setReceiver, iceP_val, context);
    }

    ::std::function<void()>
    setReceiverAsync(const ::std::shared_ptr<::Messager::ReceiverPrx>& iceP_val,
                     ::std::function<void()> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(response, ex, sent, this, &Messager::BoxPrx::_iceI_setReceiver, iceP_val, context);
    }

    void _iceI_setReceiver(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::shared_ptr<::Messager::ReceiverPrx>&, const ::Ice::Context&);

    void setReceiverId(const ::Ice::Identity& iceP_recvid, const ::Ice::Context& context = Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &Messager::BoxPrx::_iceI_setReceiverId, iceP_recvid, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto setReceiverIdAsync(const ::Ice::Identity& iceP_recvid, const ::Ice::Context& context = Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &Messager::BoxPrx::_iceI_setReceiverId, iceP_recvid, context);
    }

    ::std::function<void()>
    setReceiverIdAsync(const ::Ice::Identity& iceP_recvid,
                       ::std::function<void()> response,
                       ::std::function<void(::std::exception_ptr)> ex = nullptr,
                       ::std::function<void(bool)> sent = nullptr,
                       const ::Ice::Context& context = Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(response, ex, sent, this, &Messager::BoxPrx::_iceI_setReceiverId, iceP_recvid, context);
    }

    void _iceI_setReceiverId(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Identity&, const ::Ice::Context&);

    static const ::std::string& ice_staticId();

protected:

    BoxPrx() = default;
    friend ::std::shared_ptr<BoxPrx> IceInternal::createProxy<BoxPrx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
};

class DeliverPrx : public virtual ::Ice::Proxy<DeliverPrx, ::Ice::ObjectPrx>
{
public:

    bool registerBox(const ::Messager::BoxInfo& iceP_info, const ::Ice::Context& context = Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<bool>(true, this, &Messager::DeliverPrx::_iceI_registerBox, iceP_info, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto registerBoxAsync(const ::Messager::BoxInfo& iceP_info, const ::Ice::Context& context = Ice::noExplicitContext)
        -> decltype(::std::declval<P<bool>>().get_future())
    {
        return _makePromiseOutgoing<bool, P>(false, this, &Messager::DeliverPrx::_iceI_registerBox, iceP_info, context);
    }

    ::std::function<void()>
    registerBoxAsync(const ::Messager::BoxInfo& iceP_info,
                     ::std::function<void(bool)> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<bool>(response, ex, sent, this, &Messager::DeliverPrx::_iceI_registerBox, iceP_info, context);
    }

    void _iceI_registerBox(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>&, const ::Messager::BoxInfo&, const ::Ice::Context&);

    static const ::std::string& ice_staticId();

protected:

    DeliverPrx() = default;
    friend ::std::shared_ptr<DeliverPrx> IceInternal::createProxy<DeliverPrx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
};

}

namespace Ice
{

template<>
struct StreamableTraits<::Messager::BoxInfo>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::Messager::BoxInfo, S>
{
    static void read(S* istr, ::Messager::BoxInfo& v)
    {
        istr->readAll(v.address);
    }
};

template<>
struct StreamableTraits<::Messager::Owner>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 2;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::Messager::Owner, S>
{
    static void read(S* istr, ::Messager::Owner& v)
    {
        istr->readAll(v.id, v.boxs);
    }
};

template<>
struct StreamableTraits<::Messager::Message>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 4;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::Messager::Message, S>
{
    static void read(S* istr, ::Messager::Message& v)
    {
        istr->readAll(v.to, v.from, v.subject);
    }
};

}

namespace Messager
{

using ReceiverPtr = ::std::shared_ptr<Receiver>;
using ReceiverPrxPtr = ::std::shared_ptr<ReceiverPrx>;

using BoxPtr = ::std::shared_ptr<Box>;
using BoxPrxPtr = ::std::shared_ptr<BoxPrx>;

using DeliverPtr = ::std::shared_ptr<Deliver>;
using DeliverPrxPtr = ::std::shared_ptr<DeliverPrx>;

}

#else // C++98 mapping

namespace IceProxy
{

namespace Messager
{

class Receiver;
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< ::IceProxy::Messager::Receiver>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Messager::Receiver*);

class Box;
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< ::IceProxy::Messager::Box>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Messager::Box*);

class Deliver;
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< ::IceProxy::Messager::Deliver>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Messager::Deliver*);

}

}

namespace Messager
{

class Receiver;
::Ice::Object* upCast(::Messager::Receiver*);
typedef ::IceInternal::Handle< ::Messager::Receiver> ReceiverPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Messager::Receiver> ReceiverPrx;
typedef ReceiverPrx ReceiverPrxPtr;
void _icePatchObjectPtr(ReceiverPtr&, const ::Ice::ObjectPtr&);

class Box;
::Ice::Object* upCast(::Messager::Box*);
typedef ::IceInternal::Handle< ::Messager::Box> BoxPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Messager::Box> BoxPrx;
typedef BoxPrx BoxPrxPtr;
void _icePatchObjectPtr(BoxPtr&, const ::Ice::ObjectPtr&);

class Deliver;
::Ice::Object* upCast(::Messager::Deliver*);
typedef ::IceInternal::Handle< ::Messager::Deliver> DeliverPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Messager::Deliver> DeliverPrx;
typedef DeliverPrx DeliverPrxPtr;
void _icePatchObjectPtr(DeliverPtr&, const ::Ice::ObjectPtr&);

}

namespace Messager
{

struct BoxInfo
{
    ::std::string address;

    bool operator==(const BoxInfo& rhs_) const
    {
        if(this == &rhs_)
        {
            return true;
        }
        if(address != rhs_.address)
        {
            return false;
        }
        return true;
    }

    bool operator<(const BoxInfo& rhs_) const
    {
        if(this == &rhs_)
        {
            return false;
        }
        if(address < rhs_.address)
        {
            return true;
        }
        else if(rhs_.address < address)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const BoxInfo& rhs_) const
    {
        return !operator==(rhs_);
    }
    bool operator<=(const BoxInfo& rhs_) const
    {
        return operator<(rhs_) || operator==(rhs_);
    }
    bool operator>(const BoxInfo& rhs_) const
    {
        return !operator<(rhs_) && !operator==(rhs_);
    }
    bool operator>=(const BoxInfo& rhs_) const
    {
        return !operator<(rhs_);
    }
};

typedef ::std::vector< ::Messager::BoxInfo> BoxList;

struct Owner
{
    ::std::string id;
    ::Messager::BoxList boxs;
};

typedef ::std::vector< ::Messager::Owner> OwnerList;

struct Message
{
    ::Messager::OwnerList to;
    ::Messager::Owner from;
    ::std::string subject;
};

}

namespace Messager
{

class Callback_Receiver_onRecv_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Receiver_onRecv_Base> Callback_Receiver_onRecvPtr;

class Callback_Box_post_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Box_post_Base> Callback_Box_postPtr;

class Callback_Box_pull_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Box_pull_Base> Callback_Box_pullPtr;

class Callback_Box_setReceiver_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Box_setReceiver_Base> Callback_Box_setReceiverPtr;

class Callback_Box_setReceiverId_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Box_setReceiverId_Base> Callback_Box_setReceiverIdPtr;

class Callback_Deliver_registerBox_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Deliver_registerBox_Base> Callback_Deliver_registerBoxPtr;

}

namespace IceProxy
{

namespace Messager
{

class Receiver : public virtual ::Ice::Proxy<Receiver, ::IceProxy::Ice::Object>
{
public:

    void onRecv(const ::Messager::Message& iceP_msg, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_onRecv(_iceI_begin_onRecv(iceP_msg, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_onRecv(const ::Messager::Message& iceP_msg, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_onRecv(iceP_msg, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_onRecv(const ::Messager::Message& iceP_msg, const ::Ice::CallbackPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_onRecv(iceP_msg, ::Ice::noExplicitContext, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_onRecv(const ::Messager::Message& iceP_msg, const ::Ice::Context& context, const ::Ice::CallbackPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_onRecv(iceP_msg, context, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_onRecv(const ::Messager::Message& iceP_msg, const ::Messager::Callback_Receiver_onRecvPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_onRecv(iceP_msg, ::Ice::noExplicitContext, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_onRecv(const ::Messager::Message& iceP_msg, const ::Ice::Context& context, const ::Messager::Callback_Receiver_onRecvPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_onRecv(iceP_msg, context, del, cookie);
    }

    void end_onRecv(const ::Ice::AsyncResultPtr&);

private:

    ::Ice::AsyncResultPtr _iceI_begin_onRecv(const ::Messager::Message&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    static const ::std::string& ice_staticId();

protected:

    virtual ::IceProxy::Ice::Object* _newInstance() const;
};

class Box : public virtual ::Ice::Proxy<Box, ::IceProxy::Ice::Object>
{
public:

    bool post(const ::Messager::Message& iceP_msg, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_post(_iceI_begin_post(iceP_msg, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_post(const ::Messager::Message& iceP_msg, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_post(iceP_msg, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_post(const ::Messager::Message& iceP_msg, const ::Ice::CallbackPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_post(iceP_msg, ::Ice::noExplicitContext, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_post(const ::Messager::Message& iceP_msg, const ::Ice::Context& context, const ::Ice::CallbackPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_post(iceP_msg, context, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_post(const ::Messager::Message& iceP_msg, const ::Messager::Callback_Box_postPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_post(iceP_msg, ::Ice::noExplicitContext, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_post(const ::Messager::Message& iceP_msg, const ::Ice::Context& context, const ::Messager::Callback_Box_postPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_post(iceP_msg, context, del, cookie);
    }

    bool end_post(const ::Ice::AsyncResultPtr&);

private:

    ::Ice::AsyncResultPtr _iceI_begin_post(const ::Messager::Message&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void pull(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_pull(_iceI_begin_pull(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_pull(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_pull(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_pull(const ::Ice::CallbackPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_pull(::Ice::noExplicitContext, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_pull(const ::Ice::Context& context, const ::Ice::CallbackPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_pull(context, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_pull(const ::Messager::Callback_Box_pullPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_pull(::Ice::noExplicitContext, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_pull(const ::Ice::Context& context, const ::Messager::Callback_Box_pullPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_pull(context, del, cookie);
    }

    void end_pull(const ::Ice::AsyncResultPtr&);

private:

    ::Ice::AsyncResultPtr _iceI_begin_pull(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void setReceiver(const ::Messager::ReceiverPrx& iceP_val, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_setReceiver(_iceI_begin_setReceiver(iceP_val, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_setReceiver(const ::Messager::ReceiverPrx& iceP_val, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_setReceiver(iceP_val, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setReceiver(const ::Messager::ReceiverPrx& iceP_val, const ::Ice::CallbackPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setReceiver(iceP_val, ::Ice::noExplicitContext, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_setReceiver(const ::Messager::ReceiverPrx& iceP_val, const ::Ice::Context& context, const ::Ice::CallbackPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setReceiver(iceP_val, context, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_setReceiver(const ::Messager::ReceiverPrx& iceP_val, const ::Messager::Callback_Box_setReceiverPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setReceiver(iceP_val, ::Ice::noExplicitContext, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_setReceiver(const ::Messager::ReceiverPrx& iceP_val, const ::Ice::Context& context, const ::Messager::Callback_Box_setReceiverPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setReceiver(iceP_val, context, del, cookie);
    }

    void end_setReceiver(const ::Ice::AsyncResultPtr&);

private:

    ::Ice::AsyncResultPtr _iceI_begin_setReceiver(const ::Messager::ReceiverPrx&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void setReceiverId(const ::Ice::Identity& iceP_recvid, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_setReceiverId(_iceI_begin_setReceiverId(iceP_recvid, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_setReceiverId(const ::Ice::Identity& iceP_recvid, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_setReceiverId(iceP_recvid, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setReceiverId(const ::Ice::Identity& iceP_recvid, const ::Ice::CallbackPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setReceiverId(iceP_recvid, ::Ice::noExplicitContext, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_setReceiverId(const ::Ice::Identity& iceP_recvid, const ::Ice::Context& context, const ::Ice::CallbackPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setReceiverId(iceP_recvid, context, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_setReceiverId(const ::Ice::Identity& iceP_recvid, const ::Messager::Callback_Box_setReceiverIdPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setReceiverId(iceP_recvid, ::Ice::noExplicitContext, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_setReceiverId(const ::Ice::Identity& iceP_recvid, const ::Ice::Context& context, const ::Messager::Callback_Box_setReceiverIdPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setReceiverId(iceP_recvid, context, del, cookie);
    }

    void end_setReceiverId(const ::Ice::AsyncResultPtr&);

private:

    ::Ice::AsyncResultPtr _iceI_begin_setReceiverId(const ::Ice::Identity&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    static const ::std::string& ice_staticId();

protected:

    virtual ::IceProxy::Ice::Object* _newInstance() const;
};

class Deliver : public virtual ::Ice::Proxy<Deliver, ::IceProxy::Ice::Object>
{
public:

    bool registerBox(const ::Messager::BoxInfo& iceP_info, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_registerBox(_iceI_begin_registerBox(iceP_info, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_registerBox(const ::Messager::BoxInfo& iceP_info, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_registerBox(iceP_info, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_registerBox(const ::Messager::BoxInfo& iceP_info, const ::Ice::CallbackPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_registerBox(iceP_info, ::Ice::noExplicitContext, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_registerBox(const ::Messager::BoxInfo& iceP_info, const ::Ice::Context& context, const ::Ice::CallbackPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_registerBox(iceP_info, context, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_registerBox(const ::Messager::BoxInfo& iceP_info, const ::Messager::Callback_Deliver_registerBoxPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_registerBox(iceP_info, ::Ice::noExplicitContext, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_registerBox(const ::Messager::BoxInfo& iceP_info, const ::Ice::Context& context, const ::Messager::Callback_Deliver_registerBoxPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_registerBox(iceP_info, context, del, cookie);
    }

    bool end_registerBox(const ::Ice::AsyncResultPtr&);

private:

    ::Ice::AsyncResultPtr _iceI_begin_registerBox(const ::Messager::BoxInfo&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    static const ::std::string& ice_staticId();

protected:

    virtual ::IceProxy::Ice::Object* _newInstance() const;
};

}

}

namespace Messager
{

class Receiver : public virtual ::Ice::Object
{
public:

    typedef ReceiverPrx ProxyType;
    typedef ReceiverPtr PointerType;

    virtual ~Receiver();

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::emptyCurrent) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::emptyCurrent) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::emptyCurrent) const;

    static const ::std::string& ice_staticId();

    virtual void onRecv(const ::Messager::Message&, const ::Ice::Current& = ::Ice::emptyCurrent) = 0;
    bool _iceD_onRecv(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);

protected:

    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
};

inline bool operator==(const Receiver& lhs, const Receiver& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const Receiver& lhs, const Receiver& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}

class Box : public virtual ::Ice::Object
{
public:

    typedef BoxPrx ProxyType;
    typedef BoxPtr PointerType;

    virtual ~Box();

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::emptyCurrent) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::emptyCurrent) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::emptyCurrent) const;

    static const ::std::string& ice_staticId();

    virtual bool post(const ::Messager::Message&, const ::Ice::Current& = ::Ice::emptyCurrent) = 0;
    bool _iceD_post(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void pull(const ::Ice::Current& = ::Ice::emptyCurrent) = 0;
    bool _iceD_pull(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setReceiver(const ::Messager::ReceiverPrx&, const ::Ice::Current& = ::Ice::emptyCurrent) = 0;
    bool _iceD_setReceiver(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setReceiverId(const ::Ice::Identity&, const ::Ice::Current& = ::Ice::emptyCurrent) = 0;
    bool _iceD_setReceiverId(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);

protected:

    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
};

inline bool operator==(const Box& lhs, const Box& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const Box& lhs, const Box& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}

class Deliver : public virtual ::Ice::Object
{
public:

    typedef DeliverPrx ProxyType;
    typedef DeliverPtr PointerType;

    virtual ~Deliver();

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::emptyCurrent) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::emptyCurrent) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::emptyCurrent) const;

    static const ::std::string& ice_staticId();

    virtual bool registerBox(const ::Messager::BoxInfo&, const ::Ice::Current& = ::Ice::emptyCurrent) = 0;
    bool _iceD_registerBox(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);

protected:

    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
};

inline bool operator==(const Deliver& lhs, const Deliver& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const Deliver& lhs, const Deliver& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}

}

namespace Ice
{

template<>
struct StreamableTraits< ::Messager::BoxInfo>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::Messager::BoxInfo, S>
{
    static void write(S* ostr, const ::Messager::BoxInfo& v)
    {
        ostr->write(v.address);
    }
};

template<typename S>
struct StreamReader< ::Messager::BoxInfo, S>
{
    static void read(S* istr, ::Messager::BoxInfo& v)
    {
        istr->read(v.address);
    }
};

template<>
struct StreamableTraits< ::Messager::Owner>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 2;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::Messager::Owner, S>
{
    static void write(S* ostr, const ::Messager::Owner& v)
    {
        ostr->write(v.id);
        ostr->write(v.boxs);
    }
};

template<typename S>
struct StreamReader< ::Messager::Owner, S>
{
    static void read(S* istr, ::Messager::Owner& v)
    {
        istr->read(v.id);
        istr->read(v.boxs);
    }
};

template<>
struct StreamableTraits< ::Messager::Message>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 4;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::Messager::Message, S>
{
    static void write(S* ostr, const ::Messager::Message& v)
    {
        ostr->write(v.to);
        ostr->write(v.from);
        ostr->write(v.subject);
    }
};

template<typename S>
struct StreamReader< ::Messager::Message, S>
{
    static void read(S* istr, ::Messager::Message& v)
    {
        istr->read(v.to);
        istr->read(v.from);
        istr->read(v.subject);
    }
};

}

namespace Messager
{

template<class T>
class CallbackNC_Receiver_onRecv : public Callback_Receiver_onRecv_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Receiver_onRecv(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_Receiver_onRecvPtr
newCallback_Receiver_onRecv(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Receiver_onRecv<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Receiver_onRecvPtr
newCallback_Receiver_onRecv(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Receiver_onRecv<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Receiver_onRecvPtr
newCallback_Receiver_onRecv(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Receiver_onRecv<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Receiver_onRecvPtr
newCallback_Receiver_onRecv(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Receiver_onRecv<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Receiver_onRecv : public Callback_Receiver_onRecv_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Receiver_onRecv(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_Receiver_onRecvPtr
newCallback_Receiver_onRecv(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Receiver_onRecv<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Receiver_onRecvPtr
newCallback_Receiver_onRecv(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Receiver_onRecv<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Receiver_onRecvPtr
newCallback_Receiver_onRecv(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Receiver_onRecv<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Receiver_onRecvPtr
newCallback_Receiver_onRecv(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Receiver_onRecv<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Box_post : public Callback_Box_post_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_Box_post(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ::Messager::BoxPrx proxy = ::Messager::BoxPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_post(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }

private:

    Response _response;
};

template<class T> Callback_Box_postPtr
newCallback_Box_post(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Box_post<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Box_postPtr
newCallback_Box_post(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Box_post<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Box_post : public Callback_Box_post_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_Box_post(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ::Messager::BoxPrx proxy = ::Messager::BoxPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_post(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }

private:

    Response _response;
};

template<class T, typename CT> Callback_Box_postPtr
newCallback_Box_post(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Box_post<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Box_postPtr
newCallback_Box_post(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Box_post<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Box_pull : public Callback_Box_pull_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Box_pull(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_Box_pullPtr
newCallback_Box_pull(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Box_pull<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Box_pullPtr
newCallback_Box_pull(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Box_pull<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Box_pullPtr
newCallback_Box_pull(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Box_pull<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Box_pullPtr
newCallback_Box_pull(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Box_pull<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Box_pull : public Callback_Box_pull_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Box_pull(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_Box_pullPtr
newCallback_Box_pull(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Box_pull<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Box_pullPtr
newCallback_Box_pull(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Box_pull<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Box_pullPtr
newCallback_Box_pull(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Box_pull<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Box_pullPtr
newCallback_Box_pull(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Box_pull<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Box_setReceiver : public Callback_Box_setReceiver_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Box_setReceiver(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_Box_setReceiverPtr
newCallback_Box_setReceiver(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Box_setReceiver<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Box_setReceiverPtr
newCallback_Box_setReceiver(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Box_setReceiver<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Box_setReceiverPtr
newCallback_Box_setReceiver(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Box_setReceiver<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Box_setReceiverPtr
newCallback_Box_setReceiver(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Box_setReceiver<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Box_setReceiver : public Callback_Box_setReceiver_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Box_setReceiver(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_Box_setReceiverPtr
newCallback_Box_setReceiver(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Box_setReceiver<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Box_setReceiverPtr
newCallback_Box_setReceiver(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Box_setReceiver<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Box_setReceiverPtr
newCallback_Box_setReceiver(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Box_setReceiver<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Box_setReceiverPtr
newCallback_Box_setReceiver(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Box_setReceiver<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Box_setReceiverId : public Callback_Box_setReceiverId_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Box_setReceiverId(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_Box_setReceiverIdPtr
newCallback_Box_setReceiverId(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Box_setReceiverId<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Box_setReceiverIdPtr
newCallback_Box_setReceiverId(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Box_setReceiverId<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Box_setReceiverIdPtr
newCallback_Box_setReceiverId(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Box_setReceiverId<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Box_setReceiverIdPtr
newCallback_Box_setReceiverId(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Box_setReceiverId<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Box_setReceiverId : public Callback_Box_setReceiverId_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Box_setReceiverId(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_Box_setReceiverIdPtr
newCallback_Box_setReceiverId(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Box_setReceiverId<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Box_setReceiverIdPtr
newCallback_Box_setReceiverId(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Box_setReceiverId<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Box_setReceiverIdPtr
newCallback_Box_setReceiverId(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Box_setReceiverId<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Box_setReceiverIdPtr
newCallback_Box_setReceiverId(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Box_setReceiverId<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Deliver_registerBox : public Callback_Deliver_registerBox_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_Deliver_registerBox(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ::Messager::DeliverPrx proxy = ::Messager::DeliverPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_registerBox(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }

private:

    Response _response;
};

template<class T> Callback_Deliver_registerBoxPtr
newCallback_Deliver_registerBox(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Deliver_registerBox<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Deliver_registerBoxPtr
newCallback_Deliver_registerBox(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Deliver_registerBox<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Deliver_registerBox : public Callback_Deliver_registerBox_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_Deliver_registerBox(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ::Messager::DeliverPrx proxy = ::Messager::DeliverPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_registerBox(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }

private:

    Response _response;
};

template<class T, typename CT> Callback_Deliver_registerBoxPtr
newCallback_Deliver_registerBox(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Deliver_registerBox<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Deliver_registerBoxPtr
newCallback_Deliver_registerBox(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Deliver_registerBox<T, CT>(instance, cb, excb, sentcb);
}

}

#endif

#include <IceUtil/PopDisableWarnings.h>
#endif
